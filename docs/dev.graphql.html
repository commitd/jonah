<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GraphQL Usage · Jonah</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="The interface between UI and server is [GraphQL](http://graphql.org/)."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="GraphQL Usage · Jonah"/><meta property="og:type" content="website"/><meta property="og:url" content="https://commitd.github.io/jonah/jonah/index.html"/><meta property="og:description" content="The interface between UI and server is [GraphQL](http://graphql.org/)."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/jonah/undefined"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><link rel="stylesheet" href="/jonah/css/main.css"/></head><body class="sideNavVisible"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/jonah/"><h2 class="headerTitle">Jonah</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/jonah/docs/setup.index.html" target="_self">Setup</a></li><li class=""><a href="/jonah/docs/use.index.html" target="_self">Use</a></li><li class="siteNavGroupActive"><a href="/jonah/docs/dev.index.html" target="_self">Develop</a></li><li class=""><a href="https://github.com/commitd/jonah-server" target="_self">Server Source</a></li><li class=""><a href="https://github.com/commitd/jonah-ui" target="_self">UI Source</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><i></i></div><h2><i>›</i><span>Concepts</span></h2></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Setup</h3><ul><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.index.html">Developing Ketos</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.setup-dev-env.html">Setup a development environment</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.documentation.html">Updating documentation</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.build.html">Build</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Concepts</h3><ul><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.data.html">Data types in Ketos</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/jonah/docs/dev.graphql.html">GraphQL Usage</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.actions.html">Actions</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorials</h3><ul><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.tutorial-index.html">Basic tutorial</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.tutorial-server.html">Creating a simple server plugin</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.tutorial-ui.html">Creating a simple UI</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.tutorial-ui-actions.html">Responding to UI actions</a></li><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.tutorial-advanced.html">Advanced</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Support</h3><ul><li class="navListItem"><a class="navItem" href="/jonah/docs/dev.ui-plugins-for-devs.html">Development supporting UI plugins</a></li></ul></div></div></section></div><script>
            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              const headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                if (event.target.tagName === 'A') {
                  document.body.classList.remove('tocActive');
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 class="postHeaderTitle">GraphQL Usage</h1></header><article><div><span><p>The interface between UI and server is <a href="http://graphql.org/">GraphQL</a>.</p>
<p>Our use of GraphQL serves two purposes:</p>
<ul>
<li>It allows us to extend functionality with server plugins adding additonal fields into the schema</li>
<li>UI components can query for only the information they need which reduces the volume of data which could be provided as server side functionality increases</li>
</ul>
<p>The best way to understand Ketos' GraphQL is through the <a href="https://github.com/graphql/graphiql">GraphiQL</a> developer view, which provides a live query interface.</p>
<p>To illustrate Ketos' GraphQL features we include a number of example queries. These give a flavour of how to create queries and hence how to create UI plugins which take advantage of that data.</p>
<h2><a class="anchor" aria-hidden="true" id="example-of-ketos-graphql"></a><a href="#example-of-ketos-graphql" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example of Ketos GraphQL</h2>
<p>The schema root is at corpus level, a dataset. You can get information about a single corpus (by id):</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-selector-tag">query</span> {
  <span class="hljs-selector-tag">corpus</span>(<span class="hljs-attribute">id</span>:<span class="hljs-string">"news"</span>) {
    <span class="hljs-selector-tag">countDocuments</span>
  }
}
</code></pre>
<p>Or for all corpora, which is useful for building tables or generally aggregated results and discovering what is available in Ketos:</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-section">query</span> {
  <span class="hljs-section">corpora</span> {
   <span class="hljs-attribute">id</span>
    name
    description
    countDocuments
  }
}
</code></pre>
<p>Whilst looking at GraphQL features you can rename your fields, which is useful if you want to return the same information multiple times:</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-selector-tag">query</span> {
  <span class="hljs-attribute">news_corpus</span>: corpus(<span class="hljs-attribute">id</span>:<span class="hljs-string">"news"</span>) {
    countDocuments
  }
  <span class="hljs-attribute">wiki_corpus</span>: corpus(<span class="hljs-attribute">id</span>:<span class="hljs-string">"wiki"</span>) {
    countDocuments
  }
}
</code></pre>
<p>From a specific corpus you can select a mention, document, entity, or relation by its id:</p>
<pre><code class="hljs css languages- graphql">query {
  corpus(id:<span class="hljs-string">"news"</span>) {
    entity(id:<span class="hljs-string">"1234"</span>){
      id
      value
     <span class="hljs-built_in"> type
</span>    }
  }
}
</code></pre>
<p>Ketos attempts to standardised output from Baleen, so often you'll see commonality: for example mentions and relations both have <code>type</code>, <code>subtype</code>, <code>value</code>, <code>properties</code>, <code>begin</code>, <code>end</code>. Entities have <code>type</code>, <code>subtype</code>, <code>value</code>, <code>properties</code> too.</p>
<p>Whilst the database stores data in a denormalised way (entities have a docId field for example), Ketos normalises documents, and provides helper functions to some (or all) parts of each document. Therefore you can look up entities by document or documents by entity very easily:</p>
<pre><code class="hljs css languages- graphql">query {
  corpus(id:<span class="hljs-string">"news"</span>) {
    entity(id:<span class="hljs-string">"1234"</span>) {
        document {
            id
            <span class="hljs-builtin-name">info</span> {
                title
            }
        }
    }

    document(id:<span class="hljs-string">"abcd"</span>) {
        entities {
            id
           <span class="hljs-built_in"> type
</span>            value
        }
    }
  }
}
</code></pre>
<p>You can query by probing for data, where <code>probe</code> is a subset of the fields. This is powerful for looking up say entities by type and value, or looking for say relations which have the a specific mention:</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-selector-tag">query</span> {
  <span class="hljs-selector-tag">corpus</span>(<span class="hljs-attribute">id</span>:<span class="hljs-string">"news"</span>) {
    <span class="hljs-selector-tag">entities</span>(<span class="hljs-attribute">probe</span>: {
        <span class="hljs-attribute">type</span>: <span class="hljs-string">"Location"</span>
        <span class="hljs-attribute">value</span>: <span class="hljs-string">"United States"</span>
    }) {
        <span class="hljs-selector-tag">id</span>
        <span class="hljs-selector-tag">docId</span>
    }
  }
}
</code></pre>
<p>There are search functions which provide more power than probe matches. For example, we can look up documents which have a specific entity within them, as well as by attributes of the document:</p>
<pre><code class="hljs css languages- graphql">{
  corpus(<span class="hljs-name">id:</span> <span class="hljs-string">"news"</span>) {
    searchDocuments(<span class="hljs-name">query:</span> {content: <span class="hljs-string">"poverty"</span>}, entities: [{type: <span class="hljs-string">"Location"</span>}]) {
      hits {
        total
        # This are document results
        results {
          id
          info {
            title
          }
        }
      }
    }
  }
}
</code></pre>
<p>We can also paginate through the results aboue, as the hits object supports offset and size:</p>
<pre><code class="hljs css languages- graphql">{
  corpus(<span class="hljs-name">id:</span> <span class="hljs-string">"news"</span>) {
    searchDocuments(<span class="hljs-name">query:</span> {content: <span class="hljs-string">"poverty"</span>}, entities: [{type: <span class="hljs-string">"Location"</span>}]) {
      # Page <span class="hljs-number">2</span>...
      hits(<span class="hljs-name">offset:10</span>, size:10) {
        total
        # This are document results
        ... as before
      }
    }
  }
}
</code></pre>
<p>We can do more, for example using the same query to perform the same search but then counting the values of properties to see how documents are distributed:</p>
<pre><code class="hljs css languages- graphql">{
  corpus(<span class="hljs-name">id:</span> <span class="hljs-string">"news"</span>) {
    searchDocuments(<span class="hljs-name">query:</span> {content: <span class="hljs-string">"poverty"</span>}, entities: [{type: <span class="hljs-string">"Location"</span>}]) {
      countByField(<span class="hljs-name">field:</span><span class="hljs-string">"properties.classification"</span>) {
        bins {
          count
          term
        }
      }
    }
  }
}
</code></pre>
<p>We can also run similar aggregation counts over the entire corpus, without filtering:</p>
<pre><code class="hljs css languages- graphql">{
  corpus(<span class="hljs-name">id:</span> <span class="hljs-string">"news"</span>) {
    countByMentionField(<span class="hljs-name">field:</span><span class="hljs-string">"properties.type"</span>) {
      bins {
        count
        term
      }
    }
  }
}
</code></pre>
<p>Through combinations of these we can build quite complex queries. For example, search for all documents containing &quot;UK&quot;, take mentions of a Person called 'Prime Minister&quot; within them and then find all the related entities where Prime Minister is the source of that relation.</p>
<pre><code class="hljs css languages- graphql">{
  corpus(id: <span class="hljs-string">"news"</span>) {
    # <span class="hljs-keyword">Do</span> search
    searchDocuments(query:{
      content:<span class="hljs-string">"UK"</span>
    }) {
      hits {
        results {
          #<span class="hljs-built_in"> Filter </span>entities within the search
          entities(probe:{
            type:<span class="hljs-string">"Person"</span>,
            value:<span class="hljs-string">"Prime Minister"</span>
          }) {
            mentions {
              # <span class="hljs-builtin-name">Find</span> relations <span class="hljs-keyword">for</span> which have a source at that entity
              sourceOf {
                # <span class="hljs-builtin-name">Find</span> the target of that relation
                target {
                 <span class="hljs-built_in"> type
</span>                  value
                }
              }
            }
          }
        }
      }
    }
  }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="graphql-spqr-and-java"></a><a href="#graphql-spqr-and-java" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GraphQL SPQR and Java</h2>
<p><a href="https://github.com/leangen/graphql-spqr">GraphQL SPQR</a> is the GraphQL framework used by Ketos to resolve queries.</p>
<p>What appeals to to us about the SPQR framework is the ability to take an object returned fom another GraphQL function and extend it in a natural way. We'll use an example.</p>
<p>We return a <code>BaleenDocument</code> in many places in GraphQL, for example as a search result. The code might look like this:</p>
<pre><code class="hljs css languages- java"><span class="hljs-meta">@GraphQlQuery</span>(name=<span class="hljs-string">'simpleSearch'</span>) 
<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;BaleenDocument&gt; <span class="hljs-title">search</span><span class="hljs-params">(@GraphQlArgument(name=<span class="hljs-string">"query"</span>)</span> String query) </span>{
    <span class="hljs-comment">// ...</span>
}  
</code></pre>
<p>A GraphQL query to get back matching content would look like:</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-selector-tag">query</span> {
    <span class="hljs-selector-tag">simpleSearch</span>(<span class="hljs-attribute">query</span>:<span class="hljs-string">"UK"</span>) {
        <span class="hljs-selector-tag">id</span>
        <span class="hljs-selector-tag">content</span>
    }
}
</code></pre>
<p>The BaleenDocument consists of a list of metadata, but perhaps a plugin does not need a list, but just a count. The plugin could request all the metadata and count itself:</p>
<pre><code class="hljs css languages- graphql">query {
    simpleSearch(query:<span class="hljs-string">"UK"</span>) {
        id
        content
        metadata {
            key
            value
        }
    }
}
</code></pre>
<p>But this is wasteful. It would be better if the BaleenDocument has a <code>metadataSize</code> on it. With SPQR we can easily extend the document to include that, as a plugin that is only known at runtime:</p>
<pre><code class="hljs css languages- java"><span class="hljs-meta">@GraphQLService</span> 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendDocumentWithMetadataCount</span> </span>{

    <span class="hljs-meta">@GraphQlQuery</span>(name=<span class="hljs-string">'metadataSize'</span>) 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">metadataSize</span><span class="hljs-params">(@GraphQLContext BaleenDocument doc)</span> </span>{
        <span class="hljs-keyword">return</span> doc.getMetadata().size();
    }  
}
</code></pre>
<p>Then, with a GraphQL query:</p>
<pre><code class="hljs css languages- graphql"><span class="hljs-selector-tag">query</span> {
    <span class="hljs-selector-tag">simpleSearch</span>(<span class="hljs-attribute">query</span>:<span class="hljs-string">"UK"</span>) {
        <span class="hljs-selector-tag">id</span>
        <span class="hljs-selector-tag">content</span>
        <span class="hljs-selector-tag">metadataSize</span>
    }
}
</code></pre>
<p>It is worth noting that this metadataSize is now available whenever we query for BaleenDocuments - not just our simpleSearch query.</p>
<p>With GraphQL we can grow this functionality over time without breaking backwards compatibility. Metadata keys can be duplicated, and perhaps we want to display the number of unique metdata keys, not the toal number. We can add an argument for that (with a default value which preserves the above query).</p>
<pre><code class="hljs css languages- java"><span class="hljs-meta">@GraphQLService</span> 
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExtendDocumentWithMetadataCount</span> </span>{

    <span class="hljs-meta">@GraphQlQuery</span>(name=<span class="hljs-string">'metadataSize'</span>) 
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">metadataSize</span><span class="hljs-params">(@GraphQLContext BaleenDocument doc, 
            @GraphQLArgument(name=<span class="hljs-string">"unique"</span> defaultValue=<span class="hljs-string">"false"</span>)</span> <span class="hljs-keyword">boolean</span> unique) </span>{
        
        <span class="hljs-keyword">if</span>(unique) {
            <span class="hljs-keyword">return</span> doc.getMetadata().stream().map(BaleenDocumentMetadata::getKey).distinct().count();
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> doc.getMetadata().size();
        }
    }  
}
</code></pre>
<p>This is a simple example, but we note that <code>@GraphQLService</code> classes are in fact full Spring Service beans which have complex autowired dependencies and perform general actions, such as calling out to a third party web service. This could be used to integrate machine translation for document content or address geocoding for Locations. GraphQL provides a natural place to fuse this type of disparate services. However from the UI's perspective it is dealing with a single consistent API.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/jonah/docs/dev.data.html">← Data types in Ketos</a><a class="docs-next button" href="/jonah/docs/dev.actions.html">Actions →</a></div></div></div></div><footer class="nav-footer" id="footer"><section class="sitemap"><div><h5>Sitemap</h5><a href="/jonah/docs/setup.index.html">Setup</a><a href="/jonah/docs/use.index.html">Use</a><a href="/jonah/docs/dev.index.html">Develop</a></div><div><h5>Resources</h5><a href="https://github.com/commitd/jonah">Source</a></div></section><section class="copyright">Copyright © 2018 Committed</section></footer></div></body></html>